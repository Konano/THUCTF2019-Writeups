# -*- coding: utf-8 -*-
# @Author: NanoApe
# @Date:   2019-09-16 19:52:00
# @Last Modified by:   NanoApe
# @Last Modified time: 2019-10-01 23:35:54

import random
import sys
import os
import string
from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.number import *
from Crypto.Util.strxor import strxor
import math
import gmpy2
from libnum import *

# for c1 in (string.ascii_letters + string.digits):
#     for c2 in (string.ascii_letters + string.digits):
#         for c3 in (string.ascii_letters + string.digits):
#             for c4 in (string.ascii_letters + string.digits):
#                 proof = c1+c2+c3+c4+'tXNTTcFojQV3eVNU'
#                 digest = sha256(proof.encode('utf-8')).hexdigest()
#                 if digest == '102f66987657104e0e89b5d7798ec59c22c2ba6c535411493775e99f70bb1a84':
#                     print(proof)
#                     exit()

# msg = 3e7f58fcace6917c81903804ea9ff391

# n = 15242581721671848132038898436055921497499091285483382453570886720283096304112063726299904280306445624672036582036899387706413283665845387323910675145166646827560739202179119477075965518288258497114246061117542914424472756211365479973811489023215749899678831558631650119897991866957552079059517301800471046866388603396506626672932384252142910737275203889902964178829250109630576653127284751604617288356690955153429616102034664500504012509326759716196056230548627693651406823670459724573658278183594234935482424449278788497836121443886293812700737911003895059416646794208983286620065013721876845743958080646140025493639
# e = 65537

# enc_key = 13165916384522073604964061392830763418928457315696593928042866831564683942843944842957716397859136868728775721954489080583610182756451907570579328574894482258160361899462453903530066793926608983431533592009125990980149106635681339327610320735783746726972791633167910196671986400279018811927993312083857723959387753027185134325536990395727475271483797009944198241863069646914060326661437897334167975261846172391595052311659703444225135319243926247372530525557423856576295840529975267951274653974073699074714803366854329668807890874190127337205988291600581708744617195255985079067082821478793250191670554032710054122566
# enc_key = 684b4d3e509d71990521714d1cbb8df359e830b5dd2818a2bfbd27c9afe38cb83c523ddf1cc4e716ec039fafbd3eaa226b3275a7d7a7a76b3545511c266d9e026e96a61456ca7624529e7c3a60310601f1c95da798c1da2f2ad8a751c44206b429d8ccacd387bc9e8eb112a14acf0396b091670ac5eee16f8787abbe0c8819917e70341567160eaf61322cba9b27b90824ddc300e5a97c5d1133d4337bd2af6cc8d73791d214ee914cd5f41dd8a40aa37d472d9783185e13c9f1043aac28fa87fba4f1f801f1577a0dbafc78c5497765d8697803e7f9f280b658b718feb61bc53079b0ab1bd431c5e2a2faed168c33637ee74144c45bad3fce7244710fd11446
# enc = 'cf35fabcda7d5fb664eebc99ecb8b87d'
# IV = 'bcb2ec3bebdb500713296a00d72ec4fc'

KEY = 114186051836023819584374238902865776547

# def encrypt(e, n, message, key, IV):
#     AES_OFB = AES.new(key, AES.MODE_OFB, IV)
#     enc = AES_OFB.encrypt(message.decode("hex"))
#     encrypt_key = pow(bytes_to_long(key), e, n)
#     return encrypt_key, enc, IV

# print(encrypt(e, n, '3e7f58fcace6917c81903804ea9ff391', long_to_bytes(114186051836023819584374238902865776547), IV.decode("hex")))

# def decrypt(enc, key, IV):
#     IV = IV.decode("hex")
#     key = long_to_bytes(key).rjust(16, "\x00")
#     AES_OFB = AES.new(key, AES.MODE_OFB, IV)
#     dec = AES_OFB.decrypt(enc.decode("hex"))
#     return dec

# now = 0
# for i in range(8):
#     k = pow(2, 128-16*(i+1), n)
#     ke = pow(k, e, n)
#     key = enc_key * ke % n
#     print(hex(key))
#     text = raw_input()
#     for j in range(e-1):
#         if decrypt(enc, now / (e-1) + j * pow(2, 128-16, n),  IV).encode("hex") == text:
#             now = now / (e-1) + j * pow(2, 128-16, n)
#             print('OK')
#             break
# print(now)

n1 = 83384154825502639806588614292314452749037307481508879953345845529138415946056517925873652898311360557765601492132718053640615476143825947845866537562482505872045077345948689542875482535954439501747868687955862717113201757174353824210505471101822586295268476639159775101762308583555079286333306432888171059451
n2 = 93315113404312393817324086316581274069231471570634821675723168840937108110582637308518037081052421517339059516035783682762814023249974507002458932391173086594714853651586746807326702502875041465139788767102458261326689308972290885151879305062521930918022125807405014078677287057445847766674242668353939892011
e1 = 150723398
e2 = 233892218
c1 = 45120937041445055548317179122695598891165008396196519629377740432819485983124855512813713924846444710256708760585167682177896262557312167089486682007696666897732492529288189145086226652862706517622593655347246288185335354447171717578288320066166533553424467033211305941992591959262240463504038259407572998621
c2 = 63547743694915544195298431560892367726304564646751242276583009697554101233641038999036327466065924275990920728368363580500649227791146111155897052109564062671565426008734329227431369195858507923813759699612454684979524214348590270546595651502199370357554423376172688822897549979663208617344535309079671338007
p=gcd(n1,n2)
q1=n1/p
q2=n2/p
assert(p*q1==n1)
assert(p*q2==n2)
f1=(p-1)*(q1-1)
f2=(p-1)*(q2-1)
tmp=gcd(e1,e2)

e1=e1/tmp
e2=e2/tmp
d1=invmod(e1,f1)
d2=invmod(e2,f2)

m1=pow(c1,d1,n1)
m2=pow(c2,d2,n2)
assert pow(m1,e1,n1)==c1
assert pow(m2,e2,n2)==c2
m2=m2%q2
m1=m1%q1

m=solve_crt([m1,m2], [q1,q2])
n=q1*q2
f=(q1-1)*(q2-1)
m=m%n
d=invmod(7,f)
m=pow(m,d,n)
while m!=(gmpy2.iroot(m, 2)[0])*(gmpy2.iroot(m, 2)[0]):
    m += n

print gmpy2.iroot(m, 2)[0]
assert pow(gmpy2.iroot(m, 2)[0],e1*tmp,n1)==c1
assert pow(gmpy2.iroot(m, 2)[0],e2*tmp,n2)==c2
# assert pow(mmm,e1*tmp/2,n1)==c1
# assert pow(mmm,e2*tmp/2,n2)==c2

# p = 7045551228850518368423337595928417756833308212637208269888771168078387780873794309495059076836889370074417345824759746665950755055289061213388183918889569
# q1 = n1 / p
# q2 = n2 / p
# assert p*q1==n1
# assert p*q2==n2

# f1 = (p-1) * (q1-1)
# f2 = (p-1) * (q2-1)
# tmp = gmpy2.gcd(e1, e2)
# print tmp

# e1 = e1 / tmp
# e2 = e2 / tmp
# d1 = gmpy2.invert(e1, f1)
# d2 = gmpy2.invert(e2, f2)
# assert e1*d1%f1==1
# assert e2*d2%f2==1

# m1 = gmpy2.powmod(c1, d1, n1)
# m2 = gmpy2.powmod(c2, d2, n2)
# m3 = m1 % p
# m2 = m2 % q2
# m1 = m1 % q1
# m4 = m2 % p
# print m3
# print m4
# assert m3==m4

# m = solve_crt([m1, m2, m3], [q1, q2, p])
# assert m%q1==m1
# assert m%q2==m2
# assert m%p==m3
# # print m
# n = q1 * q2
# f = (q1-1) * (q2-1)
# m = m % n
# d = gmpy2.invert(7, f)
# m = gmpy2.powmod(m, d, n)
# print gmpy2.iroot(m, 2)
# assert gmpy2.powmod(m, 14, q1) == m1
# assert gmpy2.powmod(m, e2, n2) == c2

# # print(e2, phin)
# # print(gmpy2.gcd(e1, phin))
# # print(gmpy2.gcd(e2, phin))
# # d = gmpy2.invert(e2, phin)
plain = long_to_bytes(gmpy2.iroot(m, 2)[0])
xor_key = (long_to_bytes(KEY) * 10)[:len(plain)]
FLAG = strxor(plain, xor_key)
print(FLAG)

# # math.gcd(n1, n2)