# Faulty AES

首先解压得到 `cipher.txt`，`run.sh` 和一个二进制文件 `aes`，运行 `run.sh` 可以调用 `aes` 生成六组数据，每组数据有两个十六进制序列，是对相同的随机明文进行了两种不同加密算法后获得的密文，这六组数据所使用的密钥也都一致。

对 `aes` 逆向得到算法流程，算法一是标准的 AES，算法二在标准 AES 的基础上增加了一种操作：随机选择密文的某字节，在进行 8~10 轮加密前对将其修改成随机值。

进行分析：易知无论算法一还是算法二，其 Key Schedule 和标准 AES 一致，故每一轮的加密所用到的密钥矩阵都一致。设算法一下的密文矩阵为 A1，算法二的密文矩阵为 A2，则经过第 8 轮加密可知 A1 和 A2 最多有 4 个字节不一致（SubBytes、ShiftRows、AddRoundKey 都不会增加 A1 和 A2 不同字节个数，MixColums 则会让不同的字节在列方向上扩散），第 9 轮加密后就全部面目全非了（ 16 个字节都不同了），分析到这里感觉无路可走了……

違います！

设将 A1 与 A2 异或后的矩阵设为 A3，可以知道 A3 某一些列的相邻两个数其值是相同的，这可以由 MixColums 的运算式子证明得到；而且相同数对的位置只和被修改字节的位置有关，与其修改的值无关，也就是说知道了被修改字节位置就可以知道 A3 哪些位置上的数会相同。当然在第十轮的修改字节操作会破坏某些相同数对，只需要考虑到了就行。然后第 10 轮加密并没有 MixColums，

那么到此大概可以写一个极其暴力的程序来跑了：

先枚举每组数据所修改的字节位置 $(16^6)$ ，然后枚举每一组在第 9 轮加密过后的 A3 中每一对相同的数的值（最多 4 对最少 2 对）$(256^8)$，总的复杂度为 $16^6\times 256^8=3.095\times 10^{26}$……

写个搜索 + 剪枝吧，变换下搜索顺序啥的，大概一天之内能跑出来的（

代码见 `Faulty_AES.py`（哦这个只能搜出所有合法的修改字节位置的方案，当然后面根据字节位置出解就不难了……

